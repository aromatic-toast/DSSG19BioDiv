)
)
server <- function(input,output, session){
output$chart <- renderPlot({
a <- filter(df2, species==input$species & year>=2010 & year<=2018)
b <- as.data.frame(table(a$year))
gbif_count <- c()
for(i in seq(from = 2010, to = 2018, by = 1)){
d <-  nrow(filter(df2, year==i))
gbif_count <- c(gbif_count, d)
}
b <- cbind(b, gbif_count)
b <- mutate(b, normalized = Freq/gbif_count)
ggplot(b, aes(x = Var1, y = normalized, group = 1))+
geom_line()+
geom_point()
})
data <- reactive({
x <- df
})
output$mymap <- renderLeaflet({
df <- data()
m <- leaflet(data = df) %>%
addTiles() %>%
addMarkers(lng = ~Longitude,
lat = ~Latitude,
popup = paste("Species", df$species, "<br>",
"Common Name:", df$common),
clusterOptions = markerClusterOptions())
m
})
}
shinyApp(ui = ui, server=server)
x <- filter(df2, species=="Selasphorus rufus" & year>=2010 & year<=2018)
y <- as.data.frame(table(x$year))
gbif_count <- c()
for(i in seq(from = 2010, to = 2018, by = 1)){
d <-  nrow(filter(df2, year==i))
gbif_count <- c(gbif_count, d)
print(gbif_count)
}
y <- cbind(y, gbif_count)
y <- mutate(y, normalized = Freq/gbif_count)
# group 2
a <- filter(df2, species=="Corvus caurinus" & year>=2010 & year<=2018)
b <- as.data.frame(table(a$year))
gbif_count2 <- c()
for(i in seq(from = 2010, to = 2018, by = 1)){
d <-  nrow(filter(df2, year==i))
gbif_count2 <- c(gbif_count2, d)
print(gbif_count2)
}
b <- cbind(b, gbif_count2)
b <- mutate(b, normalized = Freq/gbif_count2)
colnames(b) <- c("Var1", "Freq", "gbif_count", "normalized")
c <- rbind(y, b)
c$species <- c(rep("Selasphorus rufus", length(seq(from = 2010, to = 2018, by = 1))),
rep("Corvus caurinus", length(seq(from = 2010, to = 2018, by = 1))))
ggplot(c, aes(x = Var1, y = normalized, group = species))+
geom_line(aes(color=species))+
geom_point(aes(color = species))
View(head(df))
runApp()
runApp()
runApp()
runApp()
saveRDS(df2, "/Users/lesley/Desktop/datasets/gbif_complete.rds")
runApp()
runApp()
runApp()
runApp()
m <- c(1,2,3)
library(shiny)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
yearly_obs <- group_by(df2, year) %>% tally()
View(yearly_obs)
nrow(filter(df2, year==2018))
nrow(filter(df2, year==1995))
yearly_obs <- group_by(df2, year) %>% tally() %>% drop_na()
View(yearly_obs)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
colnames(df2)
summary_df <- drop_na(year, species)
summary_df <- read.csv("/Users/lesley/Desktop/datasets/gbif_complete.csv",
sep = "\t",
stringsAsFactors = F,
na.strings = c("", " "))
summary_df <- drop_na(year, species)
summary_df <- read.csv("/Users/lesley/Desktop/DSSG2019/DSSG19BioDiv-master/biodiv_lesley/gbif_complete.csv",
sep = "\t",
stringsAsFactors = F,
na.strings = c("", " "))
summary_df <- summary_df %>% drop_na(year, species)
is.na(summary_df$year)
unique(is.na(summary_df$year))
unique(is.na(summary_df$species))
colnames(summary_df)
summary_df <- select(datasetKey, species, decimalLatitude, decimalLongitude, year)
summary_df <- summary_df %>% select(datasetKey, species, decimalLatitude, decimalLongitude, year)
colnames(summary_df)
View(head(summary_df))
write_csv(summary_df, "./gbif_summary_pre.csv")
runApp()
head(sort(unique(df2$species)))
runApp()
length(unique(df2$species)))
length(unique(df2$species))
x = df2 %>%
filter(species %in% input$species, year>=2010, year<=2018) %>%
group_by(species, year) %>%
tally() %>%
drop_na() %>%
add_zeros()
x = df2 %>%
filter(species=="Selasphorus rufus",year>=2010, year<=2018) %>%
group_by(species, year) %>%
tally() %>%
drop_na() %>%
add_zeros()
x$year
which(yearly_obs$year %in% x$year)
y <- yearly_obs[which(yearly_obs$year %in% x$year),]
y$year
head(x)
head(y)
class(x$n)
class(y$n)
x <- x %>% mutate(normalized = x$n/y$n)
head(x)
head(y)
runApp()
runApp()
install.packages("rgdal","rgeos", "sp" ,"GISTools")
install.packages(c("rgdal","rgeos", "sp" ,"GISTools"))
getwd()
ls
library(rgdal)
library(dplyr)
library(rgeos)
library(sp)
library(GISTools)
#setwd("C:/Users/Gabe/Desktop/DSSG19BioDiv")
#gdat = read.csv("GBif June27.csv") # This is the collapsed dataset (no years, only recency)
gdat = read.csv("gbif_summary_pre.csv") # This is the uncollapsed dataset (year information included)
if (colnames(gdat)[1] == "X") {gdat = gdat[,2:ncol(gdat)]}
gdatsp = gdat
bound = readOGR(dsn = "~/Downloads/AdminBoundaries", layer = "AdminBoundaries")
bound@data$SHAPE_STAr = round(bound@data$SHAPE_STAr) # This rounds the areas to the nearest metre squared to avoid problems with too many decimal places when writing the file
coordinates(gdatsp) = c("decimalLongitude", "decimalLatitude")
proj4string(gdatsp) = CRS("+proj=longlat +datum=WGS84")
gdatsp = spTransform(gdatsp, proj4string(bound))
# This code incorporates the UBC polygon
#ubc.coord = matrix(c(-123.26494, 49.26512, -123.26308, 49.25894, -123.25409, 49.25118, -123.22587, 49.23889, -123.19758, 49.23532,-123.1979, 49.24501, -123.2054, 49.24898,-123.20218, 49.25358,-123.20382, 49.25832,-123.21564, 49.25873,-123.21564, 49.26374,-123.22793, 49.26326,-123.22896, 49.26656,-123.22264, 49.26889,-123.2269, 49.27322,-123.22662, 49.27947,-123.24743, 49.2805,-123.26267, 49.27047,-123.26494, 49.26512), ncol = 2, byrow = TRUE)
#ubc.coord = matrix(c(-123.223952, 49.278195, -123.224796, 49.272730, -123.222808, 49.270882, -123.222808, 49.268641, -123.219675, 49.268759, -123.219495, 49.267265, -123.215277, 49.267382, -123.215398, 49.258417, -123.203288, 49.258140, -123.202864, 49.256686, -123.196597, 49.256646, -123.196718, 49.250197, -123.204491, 49.249214, -123.198949, 49.246303, -123.196780, 49.246224, -123.196898, 49.238515, -123.198525, 49.238475, -123.198586, 49.236626, -123.196899, 49.236587, -123.196899, 49.234935, -123.206900, 49.237532, -123.209431, 49.235565, -123.219976, 49.239577, -123.221662, 49.236902, -123.248681, 49.249010, -123.250528, 49.250441, -123.252837, 49.251495, -123.253761, 49.252851, -123.254570, 49.254809, -123.264734, 49.265203, -123.265081, 49.266710, -123.264273, 49.267162, -123.262659, 49.270779, -123.260463, 49.271831, -123.253076, 49.275524, -123.252037, 49.276804, -123.247420, 49.279517, -123.236335, 49.279442, -123.234257, 49.279518, -123.227567, 49.278763, -123.225500, 49.278093), ncol = 2, byrow = TRUE)
# Split up the UEL/EAA polygon(s)
line = SpatialLines(list(Lines(list(Line(cbind(c(479500,479500,484000),c(5456000,5458500,5458500)))),ID="line")), proj4string = CRS(proj4string(bound)))
line2 = SpatialLines(list(Lines(list(Line(cbind(c(481500,481500),c(5470000,5485000)))),ID="line")), proj4string = CRS(proj4string(bound)))
lpi1 = gIntersection(bound[26,],line)
blpi1 = gBuffer(lpi1, width=.0000001)
dpi1 = gDifference(bound[26,], blpi1)
runApp()
runApp()
library(shiny)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
View(yearly_obs)
runApp()
sort(c(1,5, 7))
order(c(1,5,2,0))
runApp()
colnames(yearly_obs)
ggplot(yearly_obs, aes(x = year, y = n))+
geom_col()
yearly_obs %>% filter(year>=2000, year<=2018) %>%
ggplot(yearly_obs, aes(x = year, y = n))+
geom_col()
yearly_obs %>% filter(year>=2000, year<=2018) %>%
ggplot(aes(x = year, y = n))+
geom_col()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
a <- filter(df2, species=="Selasphorus rufus" & year>=2010 & year<=2018)
b <- as.data.frame(table(a$year))
gbif_count <- c()
for(i in seq(from = 2010, to = 2018, by = 1)){
c <-  nrow(filter(df2, year==i))
gbif_count <- c(gbif_count, c)
print(gbif_count)
}
b <- cbind(b, gbif_count)
b <- mutate(b, normalized = Freq/gbif_count)
# the plot
ggplot(b, aes(x = Var1, y = normalized, group = species))+
geom_line(aes(color=species))+
geom_point(aes(color = species))+
labs(title = "Reported Species Occurrence Over Time",
x = "Year",
y = "Reported Sightings")+
theme(plot.title = element_text(face = "bold", size = 20),
axis.title.x = element_text(face = "bold", size = 14),
axis.title.y = element_text(face = "bold", size = 14),
axis.text = element_text(face = "bold", size = 14))
View(b)
a <- filter(df2, species=="Selasphorus rufus" & year>=2010 & year<=2018)
b <- as.data.frame(table(a$year))
gbif_count <- c()
for(i in seq(from = 2010, to = 2018, by = 1)){
c <-  nrow(filter(df2, year==i))
gbif_count <- c(gbif_count, c)
}
b <- cbind(b, gbif_count)
b <- mutate(b, normalized = Freq/gbif_count)
# the plot
ggplot(b, aes(x = Var1, y = normalized))+
geom_line(aes(color=species))+
geom_point(aes(color = species))+
labs(title = "Reported Species Occurrence Over Time",
x = "Year",
y = "Reported Sightings")+
theme(plot.title = element_text(face = "bold", size = 20),
axis.title.x = element_text(face = "bold", size = 14),
axis.title.y = element_text(face = "bold", size = 14),
axis.text = element_text(face = "bold", size = 14))
a <- filter(df2, species=="Selasphorus rufus" & year>=2010 & year<=2018)
b <- as.data.frame(table(a$year))
gbif_count <- c()
for(i in seq(from = 2010, to = 2018, by = 1)){
c <-  nrow(filter(df2, year==i))
gbif_count <- c(gbif_count, c)
}
b <- cbind(b, gbif_count)
b <- mutate(b, normalized = Freq/gbif_count)
# the plot
ggplot(b, aes(x = Var1, y = normalized))+
geom_line()+
geom_point()+
labs(title = "Reported Species Occurrence Over Time",
x = "Year",
y = "Reported Sightings")+
theme(plot.title = element_text(face = "bold", size = 20),
axis.title.x = element_text(face = "bold", size = 14),
axis.title.y = element_text(face = "bold", size = 14),
axis.text = element_text(face = "bold", size = 14))
a <- filter(df2, species=="Selasphorus rufus" & year>=2010 & year<=2018)
b <- as.data.frame(table(a$year))
gbif_count <- c()
for(i in seq(from = 2010, to = 2018, by = 1)){
c <-  nrow(filter(df2, year==i))
gbif_count <- c(gbif_count, c)
}
b <- cbind(b, gbif_count)
b <- mutate(b, normalized = Freq/gbif_count)
# the plot
ggplot(b, aes(x = Var1, y = normalized, group = 1))+
geom_line()+
geom_point()+
labs(title = "Reported Species Occurrence Over Time",
x = "Year",
y = "Reported Sightings")+
theme(plot.title = element_text(face = "bold", size = 20),
axis.title.x = element_text(face = "bold", size = 14),
axis.title.y = element_text(face = "bold", size = 14),
axis.text = element_text(face = "bold", size = 14))
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
# read in the specific species info data frame
species_info <- read.csv("Taxonomy_Freq", stringsAsFactors = F, na.strings = c("", " "))
getwd()
# read in the specific species info data frame
species_info <- read.csv("Taxonomy_Freq", stringsAsFactors = F, na.strings = c("", " "))
library(shiny)
library(tidyverse)
library(stringr)
# Read in the data
dfsp <- read.csv("Taxonomy_Freq.csv", stringsAsFactors = F)
df_orig <- readRDS("gbif_summary.rds")
# Record which columns in dfsp should be treated as taxonomies and which should be treated as custom tags
tax_columns = which(colnames(dfsp) %in% c("kingdom","phylum","order","class","family","genus","species"))
tax_list = colnames(dfsp)[tax_columns]
names(tax_list) = str_to_title(tax_list)
tag_columns = grep("*_binary", colnames(dfsp))
tag_list = colnames(dfsp)[tag_columns]
names(tag_list) = sub("*_binary", "", colnames(dfsp)[tag_columns])
names(tag_list) = sub("_", " ", names(tag_list))
# create a dataframe containing total num of observations for each year
yearly_obs <- group_by(df_orig, year) %>% tally() %>% drop_na()
##~~ FUNCTIONS ~~##
# Function for adding 0-value rows to aggregate tally dataframes to fill out the years between the first and last years
# Note: "data" must have exactly columns "member", "year", and "n"
add_zeros1 = function(data) {
if (class(data)[1] != "data.frame") {data = as.data.frame(data)}
for (mem in unique(data$member)) {
if(nrow(data[which(data$member==mem),]) > 1) {
min = min(data$year[which(data$member == mem)], na.rm = T)
max = max(data$year[which(data$member == mem)], na.rm = T)
for (yea in (min+1):(max-1)) {
if (!(yea %in% data$year[which(data$member == mem)])) {
data = rbind(data, data.frame(member = mem, year = as.integer(yea), n = as.integer(0), stringsAsFactors = F))
}
}
}
}
return(data)
}
# For custom tag data, aggregation is done on a column-by-column (tag-by-tag) basis, necessitating a diferent function that accepts the maximum year range of the original data so that it knows to add zeros beyond the range of an individual tag (on the plus side, we don't need to worry about single-data-point cases)
add_zeros2 = function(data, min, max) {
missing_years = setdiff(min:max, data$year)
if (length(missing_years) != 0) {
x = cbind(data.frame(setdiff(min:max, data$year), 0))
colnames(x) = c("year", "n")
return(rbind(data, x))
}
else {return(data)}
}
# Function for removing decimal places for the sake of labels
no_dec = function(x) {sprintf("%.0f", x)}
df_region <- list(df=df_orig, dfsp=dfsp, tags=tag_list, use_tags=T)
df_region$tags
df_region$tags
df_region$tags[[1]]
df_region$tags[1]
runApp()
df_region = head(df_orig, 10000)
df_region <- list(df=df_orig, dfsp=dfsp, tags=tag_list, use_tags=T)
df_region$df = head(df_orig, 10000)
# These lines of code update the two variables that determine the choices users are given in the dropdown menus so if they narrow their selection, they aren't given options that correspond to empty data
df_region$dfsp = dfsp[which(dfsp[,"species"] %in% df_region$df[,"species"]),]
nrow(df_region$dfsp)
table(df_region$dfsp$IUCN_binary)
table(df_region$dfsp$bc_red_binary)
table(df_region$dfsp$bc_blue_binary)
table(df_region$dfsp$bc_endemic_binary)
table(df_region$dfsp$pollinator_binary)
removal_tags = c()
for (i in 1:length(tag_list)) {
if (!(T %in% unique(df_region$dfsp[,tag_list[[i]]]))) {removal_tags = c(removal_tags,i)}
}
removal_tags
if (length(removal_tags) != 0) {df_region$tags = df_region$tags[!removal_tags]}
df_region$tags
df_region$tags = tag_list
if (length(removal_tags) != 0) {df_region$tags = df_region$tags[-removal_tags]}
df_region$tags
if (length(df_region$tags) == 0) {df_region$use_tags = F} else {df_region$use_tags = T}
df_region$use_tags
runApp()
library(shiny)
library(tidyverse)
library(stringr)
# Read in the data
dfsp <- read.csv("Taxonomy_Freq.csv", stringsAsFactors = F)
df_orig <- readRDS("gbif_summary.rds")
# Record which columns in dfsp should be treated as taxonomies and which should be treated as custom tags
tax_columns = which(colnames(dfsp) %in% c("kingdom","phylum","order","class","family","genus","species"))
tax_list = colnames(dfsp)[tax_columns]
names(tax_list) = str_to_title(tax_list)
tag_columns = grep("*_binary", colnames(dfsp))
tag_list = colnames(dfsp)[tag_columns]
names(tag_list) = sub("*_binary", "", colnames(dfsp)[tag_columns])
names(tag_list) = sub("_", " ", names(tag_list))
# create a dataframe containing total num of observations for each year
yearly_obs <- group_by(df_orig, year) %>% tally() %>% drop_na()
##~~ FUNCTIONS ~~##
# Function for adding 0-value rows to aggregate tally dataframes to fill out the years between the first and last years
# Note: "data" must have exactly columns "member", "year", and "n"
add_zeros1 = function(data) {
if (class(data)[1] != "data.frame") {data = as.data.frame(data)}
for (mem in unique(data$member)) {
if(nrow(data[which(data$member==mem),]) > 1) {
min = min(data$year[which(data$member == mem)], na.rm = T)
max = max(data$year[which(data$member == mem)], na.rm = T)
for (yea in (min+1):(max-1)) {
if (!(yea %in% data$year[which(data$member == mem)])) {
data = rbind(data, data.frame(member = mem, year = as.integer(yea), n = as.integer(0), stringsAsFactors = F))
}
}
}
}
return(data)
}
# For custom tag data, aggregation is done on a column-by-column (tag-by-tag) basis, necessitating a diferent function that accepts the maximum year range of the original data so that it knows to add zeros beyond the range of an individual tag (on the plus side, we don't need to worry about single-data-point cases)
add_zeros2 = function(data, min, max) {
missing_years = setdiff(min:max, data$year)
if (length(missing_years) != 0) {
x = cbind(data.frame(setdiff(min:max, data$year), 0))
colnames(x) = c("year", "n")
return(rbind(data, x))
}
else {return(data)}
}
# Function for removing decimal places for the sake of labels
no_dec = function(x) {sprintf("%.0f", x)}
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
group_by(df_orig, year) %>% tally() %>% drop_na()
colnames(df_orig)
df_king = merge(df_orig, dfsp[,c("species","kingdom")], by = "species", all.x = T)
colnames(dfsp)
king_agg = aggregate(dfsp, freq ~ kingdom + year)
king_agg = aggregate(dfsp, freq ~ kingdom + year, FUN = sum)
?aggregate
king_agg = aggregate(freq ~ kingdom + year, data = dfsp, FUN = sum)
head(dfsp[,c("species","kingdom")])
df_king = merge(df_orig, dfsp[,c("species","kingdom")], by = species, all.x = T)
df_king = merge(df_orig, dfsp[,c("species","kingdom")], by = "species", all.x = T)
head(df_king)
nrow(df_king)
nrow(df_king[which(!is.na(df_king)),])
nrow(df_king[which(!is.na(df_king$species)),])
nrow(df_king[which(!is.na(df_king$kingdom)),])
tail(df_king)
yearly_king = df_king %>% group_by(year, kingdom) %>% tally()
head(yearly_king)
nrow(yearly_king)
df_fulltax = merge(df_orig, dfsp[,c("species","kingdom","phylum","class","order","family","genus")], by = "species", all.x = T)
shiny::runApp()
library(shiny)
library(tidyverse)
library(stringr)
# Read in the data
dfsp <- read.csv("Taxonomy_Freq.csv", stringsAsFactors = F)
df_orig <- readRDS("gbif_summary.rds")
# Record which columns in dfsp should be treated as taxonomies and which should be treated as custom tags
tax_columns = which(colnames(dfsp) %in% c("kingdom","phylum","order","class","family","genus","species"))
tax_list = colnames(dfsp)[tax_columns]
names(tax_list) = str_to_title(tax_list)
tag_columns = grep("*_binary", colnames(dfsp))
tag_list = colnames(dfsp)[tag_columns]
names(tag_list) = sub("*_binary", "", colnames(dfsp)[tag_columns])
names(tag_list) = sub("_", " ", names(tag_list))
# create a dataframe containing total num of observations for each year
yearly_obs <- group_by(df_orig, year) %>% tally() %>% drop_na()
##~~ FUNCTIONS ~~##
# Function for adding 0-value rows to aggregate tally dataframes to fill out the years between the first and last years
# Note: "data" must have exactly columns "member", "year", and "n"
add_zeros1 = function(data) {
if (class(data)[1] != "data.frame") {data = as.data.frame(data)}
for (mem in unique(data$member)) {
if(nrow(data[which(data$member==mem),]) > 1) {
min = min(data$year[which(data$member == mem)], na.rm = T)
max = max(data$year[which(data$member == mem)], na.rm = T)
for (yea in (min+1):(max-1)) {
if (!(yea %in% data$year[which(data$member == mem)])) {
data = rbind(data, data.frame(member = mem, year = as.integer(yea), n = as.integer(0), stringsAsFactors = F))
}
}
}
}
return(data)
}
# For custom tag data, aggregation is done on a column-by-column (tag-by-tag) basis, necessitating a diferent function that accepts the maximum year range of the original data so that it knows to add zeros beyond the range of an individual tag (on the plus side, we don't need to worry about single-data-point cases)
add_zeros2 = function(data, min, max) {
missing_years = setdiff(min:max, data$year)
if (length(missing_years) != 0) {
x = cbind(data.frame(setdiff(min:max, data$year), 0))
colnames(x) = c("year", "n")
return(rbind(data, x))
}
else {return(data)}
}
# Function for removing decimal places for the sake of labels
no_dec = function(x) {sprintf("%.0f", x)}
head(df_orig)
